local __loaded={}local __modules={}local __orig_require=require local function __dynamic_require(...)return __orig_require(...)end local function require(name)if __loaded[name]then return __loaded[name]end local f=__modules[name]if not f then return __orig_require(name)end local ret=f()__loaded[name]=ret or true return ret end __modules["ccryptolib.internal.util"]=function()local function lassert(val,err,level)if not val then error(err,level+1)end return val end local function rebaseLE(a,base1,base2)local out={}local outlen=1 local acc=0 local mul=1 for i=1,#a do acc=acc+a[i]*mul mul=mul*base1 while mul>=base2 do local rem=acc%base2 acc=(acc-rem)/base2 mul=mul/base2 out[outlen]=rem outlen=outlen+1 end end if mul>0 then out[outlen]=acc end return out end local function bits(str)local bytes={str:byte(1,32)}local out={}for i=1,32 do local byte=bytes[i]for j=-7,0 do local bit=byte%2 out[8*i+j]=bit byte=(byte-bit)/2 end end out[1]=0 out[2]=0 out[3]=0 out[255]=1 out[256]=0 return out end local function bits8(str)return{unpack(bits(str),4)}end return{lassert=lassert,rebaseLE=rebaseLE,bits=bits,bits8=bits8,}end __modules["ccryptolib.internal.mp"]=function()local unpack=unpack or table.unpack local function carryWeak(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local ___POWER24=-24 local h00=a00+3*2^75-3*2^75 a01=a01+h00*2^___POWER24 local h01=a01+3*2^75-3*2^75 a02=a02+h01*2^___POWER24 local h02=a02+3*2^75-3*2^75 a03=a03+h02*2^___POWER24 local h03=a03+3*2^75-3*2^75 a04=a04+h03*2^___POWER24 local h04=a04+3*2^75-3*2^75 a05=a05+h04*2^___POWER24 local h05=a05+3*2^75-3*2^75 a06=a06+h05*2^___POWER24 local h06=a06+3*2^75-3*2^75 a07=a07+h06*2^___POWER24 local h07=a07+3*2^75-3*2^75 a08=a08+h07*2^___POWER24 local h08=a08+3*2^75-3*2^75 a09=a09+h08*2^___POWER24 local h09=a09+3*2^75-3*2^75 a10=a10+h09*2^___POWER24 local h10=a10+3*2^75-3*2^75 return{a00-h00,a01-h01,a02-h02,a03-h03,a04-h04,a05-h05,a06-h06,a07-h07,a08-h08,a09-h09,a10-h10,},h10*2^___POWER24 end local function carry(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local ___POWER24=-24 local l00=a00%2^24 a01=a01+(a00-l00)*2^___POWER24 local l01=a01%2^24 a02=a02+(a01-l01)*2^___POWER24 local l02=a02%2^24 a03=a03+(a02-l02)*2^___POWER24 local l03=a03%2^24 a04=a04+(a03-l03)*2^___POWER24 local l04=a04%2^24 a05=a05+(a04-l04)*2^___POWER24 local l05=a05%2^24 a06=a06+(a05-l05)*2^___POWER24 local l06=a06%2^24 a07=a07+(a06-l06)*2^___POWER24 local l07=a07%2^24 a08=a08+(a07-l07)*2^___POWER24 local l08=a08%2^24 a09=a09+(a08-l08)*2^___POWER24 local l09=a09%2^24 a10=a10+(a09-l09)*2^___POWER24 local l10=a10%2^24 local h10=(a10-l10)*2^___POWER24 return{l00,l01,l02,l03,l04,l05,l06,l07,l08,l09,l10},h10 end local function add(a,b)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local ___POWER24=-24 local b00,b01,b02,b03,b04,b05,b06,b07,b08,b09,b10=unpack(b)return{a00+b00,a01+b01,a02+b02,a03+b03,a04+b04,a05+b05,a06+b06,a07+b07,a08+b08,a09+b09,a10+b10,}end local function sub(a,b)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local ___POWER24=-24 local b00,b01,b02,b03,b04,b05,b06,b07,b08,b09,b10=unpack(b)return{a00-b00,a01-b01,a02-b02,a03-b03,a04-b04,a05-b05,a06-b06,a07-b07,a08-b08,a09-b09,a10-b10,}end local function lmul(a,b)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local ___POWER24=-24 local b00,b01,b02,b03,b04,b05,b06,b07,b08,b09,b10=unpack(b)return carry{a00*b00,a01*b00+a00*b01,a02*b00+a01*b01+a00*b02,a03*b00+a02*b01+a01*b02+a00*b03,a04*b00+a03*b01+a02*b02+a01*b03+a00*b04,a05*b00+a04*b01+a03*b02+a02*b03+a01*b04+a00*b05,a06*b00+a05*b01+a04*b02+a03*b03+a02*b04+a01*b05+a00*b06,a07*b00+a06*b01+a05*b02+a04*b03+a03*b04+a02*b05+a01*b06+a00*b07,a08*b00+a07*b01+a06*b02+a05*b03+a04*b04+a03*b05+a02*b06+a01*b07+a00*b08,a09*b00+a08*b01+a07*b02+a06*b03+a05*b04+a04*b05+a03*b06+a02*b07+a01*b08+a00*b09,a10*b00+a09*b01+a08*b02+a07*b03+a06*b04+a05*b05+a04*b06+a03*b07+a02*b08+a01*b09+a00*b10,}end local function mul(a,b)local low,of=lmul(a,b)local _,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local _,b01,b02,b03,b04,b05,b06,b07,b08,b09,b10=unpack(b)return low,(carry{of+a10*b01+a09*b02+a08*b03+a07*b04+a06*b05+a05*b06+a04*b07+a03*b08+a02*b09+a01*b10,a10*b02+a09*b03+a08*b04+a07*b05+a06*b06+a05*b07+a04*b08+a03*b09+a02*b10,a10*b03+a09*b04+a08*b05+a07*b06+a06*b07+a05*b08+a04*b09+a03*b10,a10*b04+a09*b05+a08*b06+a07*b07+a06*b08+a05*b09+a04*b10,a10*b05+a09*b06+a08*b07+a07*b08+a06*b09+a05*b10,a10*b06+a09*b07+a08*b08+a07*b09+a06*b10,a10*b07+a09*b08+a08*b09+a07*b10,a10*b08+a09*b09+a08*b10,a10*b09+a09*b10,a10*b10,0})end local function dwadd(a0,a1,b0,b1)local low,c=carry(add(a0,b0))local high=add(a1,b1)high[1]=high[1]+c return low,carry(high)end local function half(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local ___POWER24=-24 return (carryWeak{a00*0.5+a01*2^23,a02*2^23,a03*2^23,a04*2^23,a05*2^23,a06*2^23,a07*2^23,a08*2^23,a09*2^23,a10*2^23,0,})end local function third(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local ___POWER24=-24 local d00=a00*0xaaaaaa local d01=a01*0xaaaaaa+d00 local d02=a02*0xaaaaaa+d01 local d03=a03*0xaaaaaa+d02 local d04=a04*0xaaaaaa+d03 local d05=a05*0xaaaaaa+d04 local d06=a06*0xaaaaaa+d05 local d07=a07*0xaaaaaa+d06 local d08=a08*0xaaaaaa+d07 local d09=a09*0xaaaaaa+d08 local d10=a10*0xaaaaaa+d09 return (carryWeak{a00+d00,a01+d01,a02+d02,a03+d03,a04+d04,a05+d05,a06+d06,a07+d07,a08+d08,a09+d09,a10+d10,})end local function mod2(a)return a[1]%2 end local function mod3(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local ___POWER24=-24 return (a00+a01+a02+a03+a04+a05+a06+a07+a08+a09+a10)%3 end local function approx(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10=unpack(a)local ___POWER24=-24 return a00+a01*2^24+a02*2^48+a03*2^72+a04*2^96+a05*2^120+a06*2^144+a07*2^168+a08*2^192+a09*2^216+a10*2^240 end local function cmp(a,b)return approx(sub(a,b))end local function num(a)return{a,0,0,0,0,0,0,0,0,0,0}end return{carry=carry,carryWeak=carryWeak,add=add,sub=sub,dwadd=dwadd,lmul=lmul,mul=mul,half=half,third=third,mod2=mod2,mod3=mod3,approx=approx,cmp=cmp,num=num,}end __modules["ccryptolib.internal.fq"]=function()local mp=require "ccryptolib.internal.mp" local util=require "ccryptolib.internal.util" local packing=require "ccryptolib.internal.packing" local unpack=unpack or table.unpack local pfq,fmtfq=packing.compilePack("<I3I3I3I3I3I3I3I3I3I3I2")local ufq=packing.compileUnpack(fmtfq)local ufql,fmtfql=packing.compileUnpack("<I3I3I3I3I3I3I3I3I3I3I3")local ufqh,fmtfqh=packing.compileUnpack("<I3I3I3I3I3I3I3I3I3I3I1")local Q={16110573,06494812,14047250,10680220,14612958,00000020,00000000,00000000,00000000,00000000,00004096,}local T0={05537307,01942290,16765621,16628356,10618610,07072433,03735459,01369940,15276086,13038191,13409718,}local T1={11711996,01747860,08326961,03814718,01859974,13327461,16105061,07590423,04050668,08138906,00000283,}local T8={5110253,3039345,2503500,11779568,15416472,16766550,16777215,16777215,16777215,16777215,4095,}local ZERO=mp.num(0)local function reduce(a)local c=mp.sub(a,Q)if mp.approx(c)<0 then return (mp.carry(a))end return (mp.carry(c))end local function add(a,b)return reduce(mp.add(a,b))end local function neg(a)return reduce(mp.sub(Q,a))end local function sub(a,b)return add(a,neg(b))end local function mul(a,b)local t0,t1=mp.mul(a,b)local mq0,mq1=mp.mul(mp.lmul(t0,T0),Q)local _,s1=mp.dwadd(t0,t1,mq0,mq1)return reduce(s1)end local function montgomery(a)return mul(a,T1)end local function demontgomery(a)local mq0,mq1=mp.mul(mp.lmul(a,T0),Q)local _,s1=mp.dwadd(a,ZERO,mq0,mq1)return reduce(s1)end local function encode(a)return pfq(fmtfq,unpack(demontgomery(a)))end local function decode(str)local dec={ufq(fmtfq,str,1)}dec[12]=nil return montgomery(dec)end local function decodeWide(str)local low={ufql(fmtfql,str,1)}low[12]=nil local high={ufqh(fmtfqh,str,34)}high[12]=nil return add(montgomery(low),montgomery(montgomery(high)))end local function decodeClamped(str)local words={ufq(fmtfq,str,1)}words[12]=nil words[1]=bit32.band(words[1],0xfffff8)words[11]=bit32.band(words[11],0x7fff)words[11]=bit32.bor(words[11],0x4000)return montgomery(words)end local function eighth(a)return mul(a,T8)end local function bits(a)local out=util.rebaseLE(demontgomery(a),2^24,2)for i=254,289 do out[i]=nil end return out end local function makeRuleset(a,b)local dt=demontgomery(a)local et=demontgomery(b)local ft=mp.sub(dt,et)local d2=mp.mod2(dt)local e2=mp.mod2(et)local d3=mp.mod3(dt)local e3=mp.mod3(et)local ef=mp.approx(et)local ff=mp.approx(ft)local lut3={[0]=0,2,1}local rules={}while ff~=0 do if ff<0 then rules[#rules+1]=0 dt,et=et,dt d2,e2=e2,d2 d3,e3=e3,d3 ef=mp.approx(et)ft=mp.sub(dt,et)ff=-ff elseif 4*ff<ef and d3==lut3[e3]then rules[#rules+1]=1 dt,et=mp.third(mp.add(dt,ft)),mp.third(mp.sub(et,ft))d2,e2=e2,d2 d3,e3=mp.mod3(dt),mp.mod3(et)ef=mp.approx(et)elseif 4*ff<ef and d2==e2 and d3==e3 then rules[#rules+1]=2 dt=mp.half(ft)d2=mp.mod2(dt)d3=lut3[(d3-e3)%3]ft=mp.sub(dt,et)ff=mp.approx(ft)elseif ff<3*ef then rules[#rules+1]=3 dt=mp.carryWeak(ft)d2=(d2-e2)%2 d3=(d3-e3)%3 ft=mp.sub(dt,et)ff=mp.approx(ft)elseif d2==e2 then rules[#rules+1]=2 dt=mp.half(ft)d2=mp.mod2(dt)d3=lut3[(d3-e3)%3]ft=mp.sub(dt,et)ff=mp.approx(ft)elseif d2==0 then rules[#rules+1]=5 dt=mp.half(dt)d2=mp.mod2(dt)d3=lut3[d3]ft=mp.sub(dt,et)ff=mp.approx(ft)elseif d3==0 then rules[#rules+1]=6 dt=mp.carryWeak(mp.sub(mp.third(dt),et))d2=(d2-e2)%2 d3=mp.mod3(dt)ft=mp.sub(dt,et)ff=mp.approx(ft)elseif d3==lut3[e3]then rules[#rules+1]=7 dt=mp.third(mp.sub(ft,et))d3=mp.mod3(dt)ft=mp.sub(dt,et)ff=mp.approx(ft)elseif d3==e3 then rules[#rules+1]=8 dt=mp.third(ft)d2=(d2-e2)%2 d3=mp.mod3(dt)ft=mp.sub(dt,et)ff=mp.approx(ft)else rules[#rules+1]=9 et=mp.half(et)e2=mp.mod2(et)e3=lut3[e3]ef=mp.approx(et)ft=mp.sub(dt,et)ff=mp.approx(ft)end end local ubits=util.rebaseLE(dt,2^24,2)while ubits[#ubits]==0 do ubits[#ubits]=nil end return{ubits,rules}end return{add=add,sub=sub,mul=mul,encode=encode,decode=decode,decodeWide=decodeWide,decodeClamped=decodeClamped,eighth=eighth,bits=bits,makeRuleset=makeRuleset,}end __modules["ccryptolib.internal.sha512"]=function()local expect=__dynamic_require "cc.expect".expect local packing=require "ccryptolib.internal.packing" local shl=bit32.lshift local shr=bit32.rshift local bxor=bit32.bxor local bnot=bit32.bnot local band=bit32.band local p1x16,fmt1x16=packing.compilePack(">I16")local p16x4,fmt16x4=packing.compilePack(">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4")local u32x4,fmt32x4=packing.compileUnpack(">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4")local function carry64(a1,a0)local r0=a0%2^32 a1=a1+(a0-r0)/2^32 return a1%2^32,r0 end local K={0x428a2f98,0xd728ae22,0x71374491,0x23ef65cd,0xb5c0fbcf,0xec4d3b2f,0xe9b5dba5,0x8189dbbc,0x3956c25b,0xf348b538,0x59f111f1,0xb605d019,0x923f82a4,0xaf194f9b,0xab1c5ed5,0xda6d8118,0xd807aa98,0xa3030242,0x12835b01,0x45706fbe,0x243185be,0x4ee4b28c,0x550c7dc3,0xd5ffb4e2,0x72be5d74,0xf27b896f,0x80deb1fe,0x3b1696b1,0x9bdc06a7,0x25c71235,0xc19bf174,0xcf692694,0xe49b69c1,0x9ef14ad2,0xefbe4786,0x384f25e3,0x0fc19dc6,0x8b8cd5b5,0x240ca1cc,0x77ac9c65,0x2de92c6f,0x592b0275,0x4a7484aa,0x6ea6e483,0x5cb0a9dc,0xbd41fbd4,0x76f988da,0x831153b5,0x983e5152,0xee66dfab,0xa831c66d,0x2db43210,0xb00327c8,0x98fb213f,0xbf597fc7,0xbeef0ee4,0xc6e00bf3,0x3da88fc2,0xd5a79147,0x930aa725,0x06ca6351,0xe003826f,0x14292967,0x0a0e6e70,0x27b70a85,0x46d22ffc,0x2e1b2138,0x5c26c926,0x4d2c6dfc,0x5ac42aed,0x53380d13,0x9d95b3df,0x650a7354,0x8baf63de,0x766a0abb,0x3c77b2a8,0x81c2c92e,0x47edaee6,0x92722c85,0x1482353b,0xa2bfe8a1,0x4cf10364,0xa81a664b,0xbc423001,0xc24b8b70,0xd0f89791,0xc76c51a3,0x0654be30,0xd192e819,0xd6ef5218,0xd6990624,0x5565a910,0xf40e3585,0x5771202a,0x106aa070,0x32bbd1b8,0x19a4c116,0xb8d2d0c8,0x1e376c08,0x5141ab53,0x2748774c,0xdf8eeb99,0x34b0bcb5,0xe19b48a8,0x391c0cb3,0xc5c95a63,0x4ed8aa4a,0xe3418acb,0x5b9cca4f,0x7763e373,0x682e6ff3,0xd6b2b8a3,0x748f82ee,0x5defb2fc,0x78a5636f,0x43172f60,0x84c87814,0xa1f0ab72,0x8cc70208,0x1a6439ec,0x90befffa,0x23631e28,0xa4506ceb,0xde82bde9,0xbef9a3f7,0xb2c67915,0xc67178f2,0xe372532b,0xca273ece,0xea26619c,0xd186b8c7,0x21c0c207,0xeada7dd6,0xcde0eb1e,0xf57d4f7f,0xee6ed178,0x06f067aa,0x72176fba,0x0a637dc5,0xa2c898a6,0x113f9804,0xbef90dae,0x1b710b35,0x131c471b,0x28db77f5,0x23047d84,0x32caab7b,0x40c72493,0x3c9ebe0a,0x15c9bebc,0x431d67c4,0x9c100d4c,0x4cc5d4be,0xcb3e42b6,0x597f299c,0xfc657e2a,0x5fcb6fab,0x3ad6faec,0x6c44198c,0x4a475817,}local function digest(data)expect(1,data,"string")local bitlen=#data*8 local padlen=-(#data+17)%128 data=data.."\x80"..("\0"):rep(padlen)..p1x16(fmt1x16,bitlen)local h01,h00=0x6a09e667,0xf3bcc908 local h11,h10=0xbb67ae85,0x84caa73b local h21,h20=0x3c6ef372,0xfe94f82b local h31,h30=0xa54ff53a,0x5f1d36f1 local h41,h40=0x510e527f,0xade682d1 local h51,h50=0x9b05688c,0x2b3e6c1f local h61,h60=0x1f83d9ab,0xfb41bd6b local h71,h70=0x5be0cd19,0x137e2179 for i=1,#data,128 do local w={u32x4(fmt32x4,data,i)}for j=33,160,2 do local wf1,wf0=w[j-30],w[j-29]local t1=shr(wf1,1)+shl(wf0,31)local t0=shr(wf0,1)+shl(wf1,31)local u1=shr(wf1,8)+shl(wf0,24)local u0=shr(wf0,8)+shl(wf1,24)local v1=shr(wf1,7)local v0=shr(wf0,7)+shl(wf1,25)local w21,w20=w[j-4],w[j-3]local w1=shr(w21,19)+shl(w20,13)local w0=shr(w20,19)+shl(w21,13)local x0=shr(w21,29)+shl(w20,3)local x1=shr(w20,29)+shl(w21,3)local y1=shr(w21,6)local y0=shr(w20,6)+shl(w21,26)local r1,r0=w[j-32]+bxor(t1,u1,v1)+w[j-14]+bxor(w1,x1,y1),w[j-31]+bxor(t0,u0,v0)+w[j-13]+bxor(w0,x0,y0)w[j],w[j+1]=carry64(r1,r0)end local a1,a0=h01,h00 local b1,b0=h11,h10 local c1,c0=h21,h20 local d1,d0=h31,h30 local e1,e0=h41,h40 local f1,f0=h51,h50 local g1,g0=h61,h60 local h1,h0=h71,h70 for j=1,160,2 do local t1=shr(e1,14)+shl(e0,18)local t0=shr(e0,14)+shl(e1,18)local u1=shr(e1,18)+shl(e0,14)local u0=shr(e0,18)+shl(e1,14)local v0=shr(e1,9)+shl(e0,23)local v1=shr(e0,9)+shl(e1,23)local s11=bxor(t1,u1,v1)local s10=bxor(t0,u0,v0)local ch1=bxor(band(e1,f1),band(bnot(e1),g1))local ch0=bxor(band(e0,f0),band(bnot(e0),g0))local temp11=h1+s11+ch1+K[j]+w[j]local temp10=h0+s10+ch0+K[j+1]+w[j+1]local w1=shr(a1,28)+shl(a0,4)local w0=shr(a0,28)+shl(a1,4)local x0=shr(a1,2)+shl(a0,30)local x1=shr(a0,2)+shl(a1,30)local y0=shr(a1,7)+shl(a0,25)local y1=shr(a0,7)+shl(a1,25)local s01=bxor(w1,x1,y1)local s00=bxor(w0,x0,y0)local maj1=bxor(band(a1,b1),band(a1,c1),band(b1,c1))local maj0=bxor(band(a0,b0),band(a0,c0),band(b0,c0))local temp21=s01+maj1 local temp20=s00+maj0 h1=g1 h0=g0 g1=f1 g0=f0 f1=e1 f0=e0 e1,e0=carry64(d1+temp11,d0+temp10)d1=c1 d0=c0 c1=b1 c0=b0 b1=a1 b0=a0 a1,a0=carry64(temp11+temp21,temp10+temp20)end h01,h00=carry64(h01+a1,h00+a0)h11,h10=carry64(h11+b1,h10+b0)h21,h20=carry64(h21+c1,h20+c0)h31,h30=carry64(h31+d1,h30+d0)h41,h40=carry64(h41+e1,h40+e0)h51,h50=carry64(h51+f1,h50+f0)h61,h60=carry64(h61+g1,h60+g0)h71,h70=carry64(h71+h1,h70+h0)end return p16x4(fmt16x4,h01,h00,h11,h10,h21,h20,h31,h30,h41,h40,h51,h50,h61,h60,h71,h70)end return{digest=digest,}end __modules["ccryptolib.internal.fp"]=function()local packing=require "ccryptolib.internal.packing" local unpack=unpack or table.unpack local ufp,fmtfp=packing.compileUnpack("<I3I3I2I3I3I2I3I3I2I3I3I2")local I={0958640*2^0,0826664*2^22,1613251*2^43,1041528*2^64,0013673*2^85,0387171*2^107,1824679*2^128,0313839*2^149,0709440*2^170,0122635*2^192,0262782*2^213,0712905*2^234,}local function num(n)return{n,0,0,0,0,0,0,0,0,0,0,0}end local function neg(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11=unpack(a)return{-a00,-a01,-a02,-a03,-a04,-a05,-a06,-a07,-a08,-a09,-a10,-a11,}end local function add(a,b)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11=unpack(a)local b00,b01,b02,b03,b04,b05,b06,b07,b08,b09,b10,b11=unpack(b)return{a00+b00,a01+b01,a02+b02,a03+b03,a04+b04,a05+b05,a06+b06,a07+b07,a08+b08,a09+b09,a10+b10,a11+b11,}end local function sub(a,b)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11=unpack(a)local b00,b01,b02,b03,b04,b05,b06,b07,b08,b09,b10,b11=unpack(b)return{a00-b00,a01-b01,a02-b02,a03-b03,a04-b04,a05-b05,a06-b06,a07-b07,a08-b08,a09-b09,a10-b10,a11-b11,}end local function carry(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11=unpack(a)local c00,c01,c02,c03,c04,c05,c06,c07,c08,c09,c10,c11 c11=a11+3*2^306-3*2^306 a00=a00+19/2^255*c11 c00=a00+3*2^73-3*2^73 a01=a01+c00 c01=a01+3*2^94-3*2^94 a02=a02+c01 c02=a02+3*2^115-3*2^115 a03=a03+c02 c03=a03+3*2^136-3*2^136 a04=a04+c03 c04=a04+3*2^158-3*2^158 a05=a05+c04 c05=a05+3*2^179-3*2^179 a06=a06+c05 c06=a06+3*2^200-3*2^200 a07=a07+c06 c07=a07+3*2^221-3*2^221 a08=a08+c07 c08=a08+3*2^243-3*2^243 a09=a09+c08 c09=a09+3*2^264-3*2^264 a10=a10+c09 c10=a10+3*2^285-3*2^285 a11=a11-c11+c10 c11=a11+3*2^306-3*2^306 return{a00-c00+19/2^255*c11,a01-c01,a02-c02,a03-c03,a04-c04,a05-c05,a06-c06,a07-c07,a08-c08,a09-c09,a10-c10,a11-c11,}end local function canonicalize(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11=unpack(a)local c00,c01,c02,c03,c04,c05,c06,c07,c08,c09,c10,c11 c00=a00%2^22 a01=a00-c00+a01 c01=a01%2^43 a02=a01-c01+a02 c02=a02%2^64 a03=a02-c02+a03 c03=a03%2^85 a04=a03-c03+a04 c04=a04%2^107 a05=a04-c04+a05 c05=a05%2^128 a06=a05-c05+a06 c06=a06%2^149 a07=a06-c06+a07 c07=a07%2^170 a08=a07-c07+a08 c08=a08%2^192 a09=a08-c08+a09 c09=a09%2^213 a10=a09-c09+a10 c10=a10%2^234 a11=a10-c10+a11 c11=a11%2^255 c00=c00+19/2^255*(a11-c11)if c11/2^234==2^21-1 and c10/2^213==2^21-1 and c09/2^192==2^21-1 and c08/2^170==2^22-1 and c07/2^149==2^21-1 and c06/2^128==2^21-1 and c05/2^107==2^21-1 and c04/2^85==2^22-1 and c03/2^64==2^21-1 and c02/2^43==2^21-1 and c01/2^22==2^21-1 and c00>=2^22-19 then return{19-2^22+c00,0,0,0,0,0,0,0,0,0,0,0}else return{c00,c01,c02,c03,c04,c05,c06,c07,c08,c09,c10,c11}end end local function eq(a,b)local c=canonicalize(sub(a,b))for i=1,12 do if c[i]~=0 then return false end end return true end local function mul(a,b)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11=unpack(a)local b00,b01,b02,b03,b04,b05,b06,b07,b08,b09,b10,b11=unpack(b)local c00,c01,c02,c03,c04,c05,c06,c07,c08,c09,c10,c11 c00=a11*b01+a10*b02+a09*b03+a08*b04+a07*b05+a06*b06+a05*b07+a04*b08+a03*b09+a02*b10+a01*b11 c01=a11*b02+a10*b03+a09*b04+a08*b05+a07*b06+a06*b07+a05*b08+a04*b09+a03*b10+a02*b11 c02=a11*b03+a10*b04+a09*b05+a08*b06+a07*b07+a06*b08+a05*b09+a04*b10+a03*b11 c03=a11*b04+a10*b05+a09*b06+a08*b07+a07*b08+a06*b09+a05*b10+a04*b11 c04=a11*b05+a10*b06+a09*b07+a08*b08+a07*b09+a06*b10+a05*b11 c05=a11*b06+a10*b07+a09*b08+a08*b09+a07*b10+a06*b11 c06=a11*b07+a10*b08+a09*b09+a08*b10+a07*b11 c07=a11*b08+a10*b09+a09*b10+a08*b11 c08=a11*b09+a10*b10+a09*b11 c09=a11*b10+a10*b11 c10=a11*b11 c00=c00*(19/2^255)+a00*b00 c01=c01*(19/2^255)+a01*b00+a00*b01 c02=c02*(19/2^255)+a02*b00+a01*b01+a00*b02 c03=c03*(19/2^255)+a03*b00+a02*b01+a01*b02+a00*b03 c04=c04*(19/2^255)+a04*b00+a03*b01+a02*b02+a01*b03+a00*b04 c05=c05*(19/2^255)+a05*b00+a04*b01+a03*b02+a02*b03+a01*b04+a00*b05 c06=c06*(19/2^255)+a06*b00+a05*b01+a04*b02+a03*b03+a02*b04+a01*b05+a00*b06 c07=c07*(19/2^255)+a07*b00+a06*b01+a05*b02+a04*b03+a03*b04+a02*b05+a01*b06+a00*b07 c08=c08*(19/2^255)+a08*b00+a07*b01+a06*b02+a05*b03+a04*b04+a03*b05+a02*b06+a01*b07+a00*b08 c09=c09*(19/2^255)+a09*b00+a08*b01+a07*b02+a06*b03+a05*b04+a04*b05+a03*b06+a02*b07+a01*b08+a00*b09 c10=c10*(19/2^255)+a10*b00+a09*b01+a08*b02+a07*b03+a06*b04+a05*b05+a04*b06+a03*b07+a02*b08+a01*b09+a00*b10 c11=a11*b00+a10*b01+a09*b02+a08*b03+a07*b04+a06*b05+a05*b06+a04*b07+a03*b08+a02*b09+a01*b10+a00*b11 a10=c10+3*2^285-3*2^285 c11=c11+a10 a11=c11+3*2^306-3*2^306 c00=c00+19/2^255*a11 a00=c00+3*2^73-3*2^73 c01=c01+a00 a01=c01+3*2^94-3*2^94 c02=c02+a01 a02=c02+3*2^115-3*2^115 c03=c03+a02 a03=c03+3*2^136-3*2^136 c04=c04+a03 a04=c04+3*2^158-3*2^158 c05=c05+a04 a05=c05+3*2^179-3*2^179 c06=c06+a05 a06=c06+3*2^200-3*2^200 c07=c07+a06 a07=c07+3*2^221-3*2^221 c08=c08+a07 a08=c08+3*2^243-3*2^243 c09=c09+a08 a09=c09+3*2^264-3*2^264 c10=c10-a10+a09 a10=c10+3*2^285-3*2^285 c11=c11-a11+a10 a11=c11+3*2^306-3*2^306 return{c00-a00+19/2^255*a11,c01-a01,c02-a02,c03-a03,c04-a04,c05-a05,c06-a06,c07-a07,c08-a08,c09-a09,c10-a10,c11-a11,}end local function square(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11=unpack(a)local d00,d01,d02,d03,d04,d05,d06,d07,d08,d09,d10 local c00,c01,c02,c03,c04,c05,c06,c07,c08,c09,c10,c11 d00=a00+a00 d01=a01+a01 d02=a02+a02 d03=a03+a03 d04=a04+a04 d05=a05+a05 d06=a06+a06 d07=a07+a07 d08=a08+a08 d09=a09+a09 d10=a10+a10 c00=a11*d01+a10*d02+a09*d03+a08*d04+a07*d05+a06*a06 c01=a11*d02+a10*d03+a09*d04+a08*d05+a07*d06 c02=a11*d03+a10*d04+a09*d05+a08*d06+a07*a07 c03=a11*d04+a10*d05+a09*d06+a08*d07 c04=a11*d05+a10*d06+a09*d07+a08*a08 c05=a11*d06+a10*d07+a09*d08 c06=a11*d07+a10*d08+a09*a09 c07=a11*d08+a10*d09 c08=a11*d09+a10*a10 c09=a11*d10 c10=a11*a11 c00=c00*(19/2^255)+a00*a00 c01=c01*(19/2^255)+a01*d00 c02=c02*(19/2^255)+a02*d00+a01*a01 c03=c03*(19/2^255)+a03*d00+a02*d01 c04=c04*(19/2^255)+a04*d00+a03*d01+a02*a02 c05=c05*(19/2^255)+a05*d00+a04*d01+a03*d02 c06=c06*(19/2^255)+a06*d00+a05*d01+a04*d02+a03*a03 c07=c07*(19/2^255)+a07*d00+a06*d01+a05*d02+a04*d03 c08=c08*(19/2^255)+a08*d00+a07*d01+a06*d02+a05*d03+a04*a04 c09=c09*(19/2^255)+a09*d00+a08*d01+a07*d02+a06*d03+a05*d04 c10=c10*(19/2^255)+a10*d00+a09*d01+a08*d02+a07*d03+a06*d04+a05*a05 c11=a11*d00+a10*d01+a09*d02+a08*d03+a07*d04+a06*d05 a10=c10+3*2^285-3*2^285 c11=c11+a10 a11=c11+3*2^306-3*2^306 c00=c00+19/2^255*a11 a00=c00+3*2^73-3*2^73 c01=c01+a00 a01=c01+3*2^94-3*2^94 c02=c02+a01 a02=c02+3*2^115-3*2^115 c03=c03+a02 a03=c03+3*2^136-3*2^136 c04=c04+a03 a04=c04+3*2^158-3*2^158 c05=c05+a04 a05=c05+3*2^179-3*2^179 c06=c06+a05 a06=c06+3*2^200-3*2^200 c07=c07+a06 a07=c07+3*2^221-3*2^221 c08=c08+a07 a08=c08+3*2^243-3*2^243 c09=c09+a08 a09=c09+3*2^264-3*2^264 c10=c10-a10+a09 a10=c10+3*2^285-3*2^285 c11=c11-a11+a10 a11=c11+3*2^306-3*2^306 return{c00-a00+19/2^255*a11,c01-a01,c02-a02,c03-a03,c04-a04,c05-a05,c06-a06,c07-a07,c08-a08,c09-a09,c10-a10,c11-a11,}end local function kmul(a,k)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11=unpack(a)local c00,c01,c02,c03,c04,c05,c06,c07,c08,c09,c10,c11 a00=a00*k a01=a01*k a02=a02*k a03=a03*k a04=a04*k a05=a05*k a06=a06*k a07=a07*k a08=a08*k a09=a09*k a10=a10*k a11=a11*k c11=a11+3*2^306-3*2^306 a00=a00+19/2^255*c11 c00=a00+3*2^73-3*2^73 a01=a01+c00 c01=a01+3*2^94-3*2^94 a02=a02+c01 c02=a02+3*2^115-3*2^115 a03=a03+c02 c03=a03+3*2^136-3*2^136 a04=a04+c03 c04=a04+3*2^158-3*2^158 a05=a05+c04 c05=a05+3*2^179-3*2^179 a06=a06+c05 c06=a06+3*2^200-3*2^200 a07=a07+c06 c07=a07+3*2^221-3*2^221 a08=a08+c07 c08=a08+3*2^243-3*2^243 a09=a09+c08 c09=a09+3*2^264-3*2^264 a10=a10+c09 c10=a10+3*2^285-3*2^285 a11=a11-c11+c10 c11=a11+3*2^306-3*2^306 return{a00-c00+19/2^255*c11,a01-c01,a02-c02,a03-c03,a04-c04,a05-c05,a06-c06,a07-c07,a08-c08,a09-c09,a10-c10,a11-c11}end local function nsquare(a,n)for _=1,n do a=square(a)end return a end local function invert(a)local a2=square(a)local a9=mul(a,nsquare(a2,2))local a11=mul(a9,a2)local x5=mul(square(a11),a9)local x10=mul(nsquare(x5,5),x5)local x20=mul(nsquare(x10,10),x10)local x40=mul(nsquare(x20,20),x20)local x50=mul(nsquare(x40,10),x10)local x100=mul(nsquare(x50,50),x50)local x200=mul(nsquare(x100,100),x100)local x250=mul(nsquare(x200,50),x50)return mul(nsquare(x250,5),a11)end local function sqrtDiv(u,v)u=carry(u)local v2=square(v)local v3=mul(v,v2)local v6=square(v3)local v7=mul(v,v6)local uv7=mul(u,v7)local x2=mul(square(uv7),uv7)local x4=mul(nsquare(x2,2),x2)local x8=mul(nsquare(x4,4),x4)local x16=mul(nsquare(x8,8),x8)local x18=mul(nsquare(x16,2),x2)local x32=mul(nsquare(x16,16),x16)local x50=mul(nsquare(x32,18),x18)local x100=mul(nsquare(x50,50),x50)local x200=mul(nsquare(x100,100),x100)local x250=mul(nsquare(x200,50),x50)local pr=mul(nsquare(x250,2),uv7)local uv3=mul(u,v3)local b=mul(uv3,pr)local b2=square(b)local vb2=mul(v,b2)if not eq(vb2,u)then b=mul(b,I)b2=square(b)vb2=mul(v,b2)end if eq(vb2,u)then return b else return nil end end local function encode(a)a=canonicalize(a)local a00,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11=unpack(a)local bytes={}local acc=a00 local function putBytes(n)for _=1,n do local byte=acc%256 bytes[#bytes+1]=byte acc=(acc-byte)/256 end end putBytes(2)acc=acc+a01/2^16 putBytes(3)acc=acc+a02/2^40 putBytes(3)acc=acc+a03/2^64 putBytes(2)acc=acc+a04/2^80 putBytes(3)acc=acc+a05/2^104 putBytes(3)acc=acc+a06/2^128 putBytes(2)acc=acc+a07/2^144 putBytes(3)acc=acc+a08/2^168 putBytes(3)acc=acc+a09/2^192 putBytes(2)acc=acc+a10/2^208 putBytes(3)acc=acc+a11/2^232 putBytes(3)return string.char(unpack(bytes))end local function decode(b)local w00,w01,w02,w03,w04,w05,w06,w07,w08,w09,w10,w11=ufp(fmtfp,b,1)w11=w11%2^15 return carry{w00,w01*2^24,w02*2^48,w03*2^64,w04*2^88,w05*2^112,w06*2^128,w07*2^152,w08*2^176,w09*2^192,w10*2^216,w11*2^240,}end local function eqz(a)local c=canonicalize(a)local c00,c01,c02,c03,c04,c05,c06,c07,c08,c09,c10,c11=unpack(c)return c00+c01+c02+c03+c04+c05+c06+c07+c08+c09+c10+c11==0 end return{num=num,neg=neg,add=add,sub=sub,kmul=kmul,mul=mul,canonicalize=canonicalize,square=square,carry=carry,invert=invert,sqrtDiv=sqrtDiv,encode=encode,decode=decode,eqz=eqz,}end __modules["ccryptolib.internal.edwards25519"]=function()local fp=require "ccryptolib.internal.fp" local unpack=unpack or table.unpack local D=fp.mul(fp.num(-121665),fp.invert(fp.num(121666)))local K=fp.kmul(D,2)local O={fp.num(0),fp.num(1),fp.num(1),fp.num(0)}local G=nil local function double(P1)local P1x,P1y,P1z=unpack(P1)local a=fp.square(P1x)local b=fp.square(P1y)local c=fp.square(P1z)local d=fp.add(c,c)local e=fp.add(a,b)local f=fp.add(P1x,P1y)local g=fp.square(f)local h=fp.carry(fp.sub(g,e))local i=fp.sub(b,a)local j=fp.carry(fp.sub(d,i))local P3x=fp.mul(h,j)local P3y=fp.mul(i,e)local P3z=fp.mul(j,i)local P3t=fp.mul(h,e)return{P3x,P3y,P3z,P3t}end local function add(P1,N2)local P1x,P1y,P1z,P1t=unpack(P1)local N1p,N1m,N1z,N1t=unpack(N2)local a=fp.sub(P1y,P1x)local b=fp.mul(a,N1m)local c=fp.add(P1y,P1x)local d=fp.mul(c,N1p)local e=fp.mul(P1t,N1t)local f=fp.mul(P1z,N1z)local g=fp.sub(d,b)local h=fp.sub(f,e)local i=fp.add(f,e)local j=fp.add(d,b)local P3x=fp.mul(g,h)local P3y=fp.mul(i,j)local P3z=fp.mul(h,i)local P3t=fp.mul(g,j)return{P3x,P3y,P3z,P3t}end local function sub(P1,N2)local P1x,P1y,P1z,P1t=unpack(P1)local N1p,N1m,N1z,N1t=unpack(N2)local a=fp.sub(P1y,P1x)local b=fp.mul(a,N1p)local c=fp.add(P1y,P1x)local d=fp.mul(c,N1m)local e=fp.mul(P1t,N1t)local f=fp.mul(P1z,N1z)local g=fp.sub(d,b)local h=fp.add(f,e)local i=fp.sub(f,e)local j=fp.add(d,b)local P3x=fp.mul(g,h)local P3y=fp.mul(i,j)local P3z=fp.mul(h,i)local P3t=fp.mul(g,j)return{P3x,P3y,P3z,P3t}end local function niels(P1)local P1x,P1y,P1z,P1t=unpack(P1)local N3p=fp.add(P1y,P1x)local N3m=fp.sub(P1y,P1x)local N3z=fp.add(P1z,P1z)local N3t=fp.mul(P1t,K)return{N3p,N3m,N3z,N3t}end local function scale(P1)local P1x,P1y,P1z=unpack(P1)local zInv=fp.invert(P1z)local P3x=fp.mul(P1x,zInv)local P3y=fp.mul(P1y,zInv)local P3z=fp.num(1)local P3t=fp.mul(P3x,P3y)return{P3x,P3y,P3z,P3t}end local function encode(P1)P1=scale(P1)local P1x,P1y=unpack(P1)local y=fp.encode(P1y)local xBit=fp.canonicalize(P1x)[1]%2 return y:sub(1,-2)..string.char(y:byte(-1)+xBit*128)end local function decode(str)local P3y=fp.decode(str)local a=fp.square(P3y)local b=fp.sub(a,fp.num(1))local c=fp.mul(a,D)local d=fp.add(c,fp.num(1))local P3x=fp.sqrtDiv(b,d)if not P3x then return nil end local xBit=fp.canonicalize(P3x)[1]%2 if xBit~=bit32.extract(str:byte(-1),7)then P3x=fp.carry(fp.neg(P3x))end local P3z=fp.num(1)local P3t=fp.mul(P3x,P3y)return{P3x,P3y,P3z,P3t}end G=decode("Xfffffffffffffffffffffffffffffff")local function signedRadixW(bits,w)local wPow=2^w local wPowh=wPow/2 local out={}local acc=0 local mul=1 for i=1,#bits do acc=acc+bits[i]*mul mul=mul*2 while i==#bits and acc>0 or mul>wPow do local rem=acc%wPow if rem>=wPowh then rem=rem-wPow end acc=(acc-rem)/wPow mul=mul/wPow out[#out+1]=rem end end return out end local function radixWTable(P,w)local out={}for i=1,math.ceil(256/w)do local row={niels(P)}for j=2,2^w/2 do P=add(P,row[1])row[j]=niels(P)end out[i]=row P=double(P)end return out end local G_W=5 local G_TABLE=radixWTable(G,G_W)local function wNaf(bits,w)local wPow=2^w local wPowh=wPow/2 local out={}local acc=0 local mul=1 for i=1,#bits do acc=acc+bits[i]*mul mul=mul*2 while i==#bits and acc>0 or mul>wPow do if acc%2==0 then acc=acc/2 mul=mul/2 out[#out+1]=0 else local rem=acc%wPow if rem>=wPowh then rem=rem-wPow end acc=acc-rem out[#out+1]=rem end end end while out[#out]==0 do out[#out]=nil end return out end local function WNAFTable(P,w)local dP=double(P)local out={niels(P)}for i=3,2^w,2 do out[i]=niels(add(dP,out[i-2]))end return out end local function mulG(bits)local sw=signedRadixW(bits,G_W)local R=O for i=1,#sw do local b=sw[i]if b>0 then R=add(R,G_TABLE[i][b])elseif b<0 then R=sub(R,G_TABLE[i][-b])end end return R end local function mul(P,bits)local naf=wNaf(bits,5)local tbl=WNAFTable(P,5)local R=O for i=#naf,1,-1 do local b=naf[i]if b==0 then R=double(R)elseif b>0 then R=add(R,tbl[b])else R=sub(R,tbl[-b])end end return R end return{double=double,add=add,sub=sub,niels=niels,scale=scale,encode=encode,decode=decode,mulG=mulG,mul=mul,}end __modules["ccryptolib.blake3"]=function()local expect=__dynamic_require "cc.expect".expect local lassert=require "ccryptolib.internal.util".lassert local packing=require "ccryptolib.internal.packing" local unpack=unpack or table.unpack local bxor=bit32.bxor local rol=bit32.lrotate local p16x4,fmt16x4=packing.compilePack("<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4")local u16x4=packing.compileUnpack(fmt16x4)local u8x4,fmt8x4=packing.compileUnpack("<I4I4I4I4I4I4I4I4")local CHUNK_START=0x01 local CHUNK_END=0x02 local PARENT=0x04 local ROOT=0x08 local KEYED_HASH=0x10 local DERIVE_KEY_CONTEXT=0x20 local DERIVE_KEY_MATERIAL=0x40 local IV={0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19,}local function compress(h,msg,t,v14,v15,full)local h00,h01,h02,h03,h04,h05,h06,h07=unpack(h)local v00,v01,v02,v03=h00,h01,h02,h03 local v04,v05,v06,v07=h04,h05,h06,h07 local v08,v09,v10,v11=0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a local v12=t%2^32 local ___V13=-32 local v13=(t-v12)*2^___V13 local m00,m01,m02,m03,m04,m05,m06,m07,m08,m09,m10,m11,m12,m13,m14,m15=unpack(msg)local tmp for i=1,7 do v00=v00+v04+m00 v12=rol(bxor(v12,v00),16)v08=v08+v12 v04=rol(bxor(v04,v08),20)v00=v00+v04+m01 v12=rol(bxor(v12,v00),24)v08=v08+v12 v04=rol(bxor(v04,v08),25)v01=v01+v05+m02 v13=rol(bxor(v13,v01),16)v09=v09+v13 v05=rol(bxor(v05,v09),20)v01=v01+v05+m03 v13=rol(bxor(v13,v01),24)v09=v09+v13 v05=rol(bxor(v05,v09),25)v02=v02+v06+m04 v14=rol(bxor(v14,v02),16)v10=v10+v14 v06=rol(bxor(v06,v10),20)v02=v02+v06+m05 v14=rol(bxor(v14,v02),24)v10=v10+v14 v06=rol(bxor(v06,v10),25)v03=v03+v07+m06 v15=rol(bxor(v15,v03),16)v11=v11+v15 v07=rol(bxor(v07,v11),20)v03=v03+v07+m07 v15=rol(bxor(v15,v03),24)v11=v11+v15 v07=rol(bxor(v07,v11),25)v00=v00+v05+m08 v15=rol(bxor(v15,v00),16)v10=v10+v15 v05=rol(bxor(v05,v10),20)v00=v00+v05+m09 v15=rol(bxor(v15,v00),24)v10=v10+v15 v05=rol(bxor(v05,v10),25)v01=v01+v06+m10 v12=rol(bxor(v12,v01),16)v11=v11+v12 v06=rol(bxor(v06,v11),20)v01=v01+v06+m11 v12=rol(bxor(v12,v01),24)v11=v11+v12 v06=rol(bxor(v06,v11),25)v02=v02+v07+m12 v13=rol(bxor(v13,v02),16)v08=v08+v13 v07=rol(bxor(v07,v08),20)v02=v02+v07+m13 v13=rol(bxor(v13,v02),24)v08=v08+v13 v07=rol(bxor(v07,v08),25)v03=v03+v04+m14 v14=rol(bxor(v14,v03),16)v09=v09+v14 v04=rol(bxor(v04,v09),20)v03=v03+v04+m15 v14=rol(bxor(v14,v03),24)v09=v09+v14 v04=rol(bxor(v04,v09),25)if i~=7 then tmp=m02 m02=m03 m03=m10 m10=m12 m12=m09 m09=m11 m11=m05 m05=m00 m00=tmp tmp=m06 m06=m04 m04=m07 m07=m13 m13=m14 m14=m15 m15=m08 m08=m01 m01=tmp end end if full then return{bxor(v00,v08),bxor(v01,v09),bxor(v02,v10),bxor(v03,v11),bxor(v04,v12),bxor(v05,v13),bxor(v06,v14),bxor(v07,v15),bxor(v08,h00),bxor(v09,h01),bxor(v10,h02),bxor(v11,h03),bxor(v12,h04),bxor(v13,h05),bxor(v14,h06),bxor(v15,h07),}else return{bxor(v00,v08),bxor(v01,v09),bxor(v02,v10),bxor(v03,v11),bxor(v04,v12),bxor(v05,v13),bxor(v06,v14),bxor(v07,v15),}end end local function merge(cvl,cvr)for i=1,8 do cvl[i+8]=cvr[i]end return cvl end local function blake3(iv,flags,msg,len)local stateCvs={}local stateCv=iv local stateT=0 local stateN=0 local stateStart=CHUNK_START local stateEnd=0 for i=1,#msg-64,64 do local block={u16x4(fmt16x4,msg,i)}local stateFlags=flags+stateStart+stateEnd stateCv=compress(stateCv,block,stateT,64,stateFlags)stateStart=0 stateN=stateN+1 if stateN==15 then stateEnd=CHUNK_END elseif stateN==16 then local mergeCv=stateCv local mergeAmt=stateT+1 while mergeAmt%2==0 do local block=merge(table.remove(stateCvs),mergeCv)mergeCv=compress(iv,block,0,64,flags+PARENT)mergeAmt=mergeAmt/2 end table.insert(stateCvs,mergeCv)stateCv=iv stateT=stateT+1 stateN=0 stateStart=CHUNK_START stateEnd=0 end end local lastLen=#msg==0 and 0 or (#msg-1)%64+1 local padded=msg:sub(-lastLen)..("\0"):rep(64)local last={u16x4(fmt16x4,padded,1)}local outCv,outBlock,outLen,outFlags if stateT>0 then local stateFlags=flags+stateStart+CHUNK_END local mergeCv=compress(stateCv,last,stateT,lastLen,stateFlags)for i=#stateCvs,2,-1 do local block=merge(stateCvs[i],mergeCv)mergeCv=compress(iv,block,0,64,flags+PARENT)end outCv=iv outBlock=merge(stateCvs[1],mergeCv)outLen=64 outFlags=flags+ROOT+PARENT else outCv=stateCv outBlock=last outLen=lastLen outFlags=flags+stateStart+CHUNK_END+ROOT end local out={}for i=0,len/64 do local md=compress(outCv,outBlock,i,outLen,outFlags,true)out[i+1]=p16x4(fmt16x4,unpack(md))end return table.concat(out):sub(1,len)end local function digest(message,len)expect(1,message,"string")len=expect(2,len,"number","nil")or 32 lassert(len%1==0,"desired output length must be an integer",2)lassert(len>=1,"desired output length must be positive",2)return blake3(IV,0,message,len)end local function digestKeyed(key,message,len)expect(1,key,"string")lassert(#key==32,"key length must be 32",2)expect(2,message,"string")len=expect(3,len,"number","nil")or 32 lassert(len%1==0,"desired output length must be an integer",2)lassert(len>=1,"desired output length must be positive",2)return blake3({u8x4(fmt8x4,key,1)},KEYED_HASH,message,len)end local function deriveKey(context)expect(1,context,"string")local iv={u8x4(fmt8x4,blake3(IV,DERIVE_KEY_CONTEXT,context,32),1)}return function(material,len)expect(1,material,"string")len=expect(2,len,"number","nil")or 32 lassert(len%1==0,"desired output length must be an integer",2)lassert(len>=1,"desired output length must be positive",2)return blake3(iv,DERIVE_KEY_MATERIAL,material,len)end end return{digest=digest,digestKeyed=digestKeyed,deriveKey=deriveKey,}end __modules["ccryptolib.chacha20"]=function()local expect=__dynamic_require "cc.expect".expect local lassert=require "ccryptolib.internal.util".lassert local packing=require "ccryptolib.internal.packing" local bxor=bit32.bxor local rol=bit32.lrotate local u8x4,fmt8x4=packing.compileUnpack("<I4I4I4I4I4I4I4I4")local u3x4,fmt3x4=packing.compileUnpack("<I4I4I4")local p16x4,fmt16x4=packing.compilePack("<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4")local u16x4=packing.compileUnpack(fmt16x4)local function crypt(key,nonce,message,rounds,offset)expect(1,key,"string")lassert(#key==32,"key length must be 32",2)expect(2,nonce,"string")lassert(#nonce==12,"nonce length must be 12",2)expect(3,message,"string")rounds=expect(4,rounds,"number","nil")or 20 lassert(rounds%2==0,"round number must be even",2)lassert(rounds>=8,"round number must be no smaller than 8",2)lassert(rounds<=20,"round number must be no larger than 20",2)offset=expect(5,offset,"number","nil")or 1 lassert(offset%1==0,"offset must be an integer",2)lassert(offset>=0,"offset must be nonnegative",2)lassert(#message+64*offset<=2^38,"offset too large",2)local i0,i1,i2,i3=0x61707865,0x3320646e,0x79622d32,0x6b206574 local k0,k1,k2,k3,k4,k5,k6,k7=u8x4(fmt8x4,key,1)local cr,n0,n1,n2=offset,u3x4(fmt3x4,nonce,1)local padded=message..("\0"):rep(-#message%64)local out={}local idx=1 for i=1,#padded/64 do local s00,s01,s02,s03=i0,i1,i2,i3 local s04,s05,s06,s07=k0,k1,k2,k3 local s08,s09,s10,s11=k4,k5,k6,k7 local s12,s13,s14,s15=cr,n0,n1,n2 for _=1,rounds,2 do s00=s00+s04 s12=rol(bxor(s12,s00),16)s08=s08+s12 s04=rol(bxor(s04,s08),12)s00=s00+s04 s12=rol(bxor(s12,s00),8)s08=s08+s12 s04=rol(bxor(s04,s08),7)s01=s01+s05 s13=rol(bxor(s13,s01),16)s09=s09+s13 s05=rol(bxor(s05,s09),12)s01=s01+s05 s13=rol(bxor(s13,s01),8)s09=s09+s13 s05=rol(bxor(s05,s09),7)s02=s02+s06 s14=rol(bxor(s14,s02),16)s10=s10+s14 s06=rol(bxor(s06,s10),12)s02=s02+s06 s14=rol(bxor(s14,s02),8)s10=s10+s14 s06=rol(bxor(s06,s10),7)s03=s03+s07 s15=rol(bxor(s15,s03),16)s11=s11+s15 s07=rol(bxor(s07,s11),12)s03=s03+s07 s15=rol(bxor(s15,s03),8)s11=s11+s15 s07=rol(bxor(s07,s11),7)s00=s00+s05 s15=rol(bxor(s15,s00),16)s10=s10+s15 s05=rol(bxor(s05,s10),12)s00=s00+s05 s15=rol(bxor(s15,s00),8)s10=s10+s15 s05=rol(bxor(s05,s10),7)s01=s01+s06 s12=rol(bxor(s12,s01),16)s11=s11+s12 s06=rol(bxor(s06,s11),12)s01=s01+s06 s12=rol(bxor(s12,s01),8)s11=s11+s12 s06=rol(bxor(s06,s11),7)s02=s02+s07 s13=rol(bxor(s13,s02),16)s08=s08+s13 s07=rol(bxor(s07,s08),12)s02=s02+s07 s13=rol(bxor(s13,s02),8)s08=s08+s13 s07=rol(bxor(s07,s08),7)s03=s03+s04 s14=rol(bxor(s14,s03),16)s09=s09+s14 s04=rol(bxor(s04,s09),12)s03=s03+s04 s14=rol(bxor(s14,s03),8)s09=s09+s14 s04=rol(bxor(s04,s09),7)end local m00,m01,m02,m03,m04,m05,m06,m07 local m08,m09,m10,m11,m12,m13,m14,m15 m00,m01,m02,m03,m04,m05,m06,m07,m08,m09,m10,m11,m12,m13,m14,m15,idx=u16x4(fmt16x4,padded,idx)out[i]=p16x4(fmt16x4,bxor(m00,s00+i0),bxor(m01,s01+i1),bxor(m02,s02+i2),bxor(m03,s03+i3),bxor(m04,s04+k0),bxor(m05,s05+k1),bxor(m06,s06+k2),bxor(m07,s07+k3),bxor(m08,s08+k4),bxor(m09,s09+k5),bxor(m10,s10+k6),bxor(m11,s11+k7),bxor(m12,s12+cr),bxor(m13,s13+n0),bxor(m14,s14+n1),bxor(m15,s15+n2))cr=cr+1 end return table.concat(out):sub(1,#message)end return{crypt=crypt,}end __modules["ccryptolib.internal.packing"]=function()local fmt=string.format local function mkPack(words,BE)local out="local C=string.char return function(_," local nb=0 for i=1,#words do out=out..fmt("n%d,",i)nb=nb+words[i]end out=out:sub(1,-2)..")local " for i=1,nb do out=out..fmt("b%d,",i)end out=out:sub(1,-2).." " local bi=1 for i=1,#words do for _=1,words[i]-1 do out=out..fmt("b%d=n%d%%2^8 n%d=(n%d-b%d)*2^-8 ",bi,i,i,i,bi)bi=bi+1 end bi=bi+1 end out=out.."return C(" bi=1 if not BE then for i=1,#words do for _=1,words[i]-1 do out=out..fmt("b%d,",bi)bi=bi+1 end out=out..fmt("n%d%%2^8,",i)bi=bi+1 end else for i=1,#words do out=out..fmt("n%d%%2^8,",i)bi=bi+words[i]-2 for _=1,words[i]-1 do out=out..fmt("b%d,",bi)bi=bi-1 end bi=bi+words[i]+1 end end out=out:sub(1,-2)..")end" return load(out)()end local function mkUnpack(words,BE)local out="local B=string.byte return function(_,s,i)local " local bi=1 if not BE then for i=1,#words do for _=1,words[i]do out=out..fmt("b%d,",bi)bi=bi+1 end end else for i=1,#words do bi=bi+words[i]-1 for _=1,words[i]do out=out..fmt("b%d,",bi)bi=bi-1 end bi=bi+words[i]+1 end end out=out:sub(1,-2)..fmt("=B(s,i,i+%d)return ",bi-2)bi=1 for i=1,#words do out=out..fmt("b%d",bi)bi=bi+1 for j=2,words[i]do out=out..fmt("+b%d*2^%d",bi,8*j-8)bi=bi+1 end out=out.."," end out=out..fmt("i+%d end",bi-1)return load(out)()end if not string.pack or pcall(string.dump,string.pack)then local function compile(fmt,fn)local e=assert(fmt:match("^([><])I[I%d]+$"),"invalid format string")local w={}for i in fmt:gmatch("I([%d]+)")do local n=tonumber(i)or 4 assert(n>0 and n<=16,"integral size out of limits")w[#w+1]=n end return fn(w,e==">")end local packCache={}local unpackCache={}local function compilePack(fmt)if not packCache[fmt]then packCache[fmt]=compile(fmt,mkPack)end return packCache[fmt],fmt end local function compileUnpack(fmt)if not unpackCache[fmt]then unpackCache[fmt]=compile(fmt,mkUnpack)end return unpackCache[fmt],fmt end return{compilePack=compilePack,compileUnpack=compileUnpack,}else local function compilePack(fmt)return string.pack,fmt end local function compileUnpack(fmt)return string.unpack,fmt end return{compilePack=compilePack,compileUnpack=compileUnpack,}end end __modules["ccryptolib.random"]=function()local expect=__dynamic_require "cc.expect".expect local blake3=require "ccryptolib.blake3" local chacha20=require "ccryptolib.chacha20" local util=require "ccryptolib.internal.util" local lassert=util.lassert local ctx={"ccryptolib 2023-04-11T19:43Z random.lua initialization context",os.epoch("utc"),os.day(),os.time(),math.random(0,2^24-1),math.random(0,2^24-1),tostring({}),tostring({}),}local state=blake3.digest(table.concat(ctx,"|"))local initialized=false local function init(seed)expect(1,seed,"string")state=blake3.digestKeyed(state,seed)initialized=true end local function isInit()return initialized end local function initWithTiming()assert(os.epoch("utc")~=0)local f=assert(load("local e=os.epoch return{"..("e'utc',"):rep(256).."}"))do local t=f()while t[256]-t[1]>1 do t=f()end end local buf={}for i=1,512 do local t=f()while t[256]==t[1]do t=f()end for j=1,256 do if t[j]~=t[1]then buf[i]=j-1 break end end end local hist={}for i=0,255 do hist[i]=0 end for i=1,#buf do hist[buf[i]]=hist[buf[i]]+1 end for i=0,255 do assert(hist[i]<20)end init(string.char(table.unpack(buf)))end local function mix(data)expect(1,data,"string")state=blake3.digestKeyed(state,data)end local function random(len)expect(1,len,"number")lassert(initialized,"attempt to use an uninitialized random generator",2)local msg=("\0"):rep(math.max(len,0)+32)local nonce=("\0"):rep(12)local out=chacha20.crypt(state,nonce,msg,8,0)state=out:sub(1,32)return out:sub(33)end return{init=init,isInit=isInit,initWithTiming=initWithTiming,mix=mix,random=random,}end __modules["ccryptolib.ed25519"]=function()local expect=__dynamic_require "cc.expect".expect local lassert=require "ccryptolib.internal.util".lassert local fq=require "ccryptolib.internal.fq" local sha512=require "ccryptolib.internal.sha512" local ed=require "ccryptolib.internal.edwards25519" local random=require "ccryptolib.random" local function publicKey(sk)expect(1,sk,"string")assert(#sk==32,"secret key length must be 32")local h=sha512.digest(sk)local x=fq.decodeClamped(h:sub(1,32))return ed.encode(ed.mulG(fq.bits(x)))end local function sign(sk,pk,msg)expect(1,sk,"string")lassert(#sk==32,"secret key length must be 32",2)expect(2,pk,"string")lassert(#pk==32,"public key length must be 32",2)expect(3,msg,"string")local h=sha512.digest(sk)local x=fq.decodeClamped(h:sub(1,32))local k=fq.decodeWide(random.random(64))local r=ed.mulG(fq.bits(k))local rStr=ed.encode(r)local e=fq.decodeWide(sha512.digest(rStr..pk..msg))local m=fq.decodeWide(random.random(64))local s=fq.sub(fq.add(k,fq.mul(fq.add(x,m),e)),fq.mul(m,e))local sStr=fq.encode(s)return rStr..sStr end local function verify(pk,msg,sig)expect(1,pk,"string")lassert(#pk==32,"public key length must be 32",2)expect(2,msg,"string")expect(3,sig,"string")lassert(#sig==64,"signature length must be 64",2)local y=ed.decode(pk)if not y then return false end local rStr=sig:sub(1,32)local sStr=sig:sub(33)local e=fq.decodeWide(sha512.digest(rStr..pk..msg))local gs=ed.mulG(fq.bits(fq.decode(sStr)))local ye=ed.mul(y,fq.bits(e))local rv=ed.sub(gs,ed.niels(ye))return ed.encode(rv)==rStr end return{publicKey=publicKey,sign=sign,verify=verify,}end __modules["wallets"]=function()local blake3=require "ccryptolib.blake3".digest local rand=require "ccryptolib.random" rand.initWithTiming()local function getPrivate()local drive if peripheral.getType("left")=="drive" then drive=peripheral.wrap("left")elseif peripheral.getType("right")=="drive" then drive=peripheral.wrap("right")else error("Please place only one disk drive on the left or righ side of the computer.")end assert(drive.isDiskPresent(),"No disk inside disk drive!")drive.setDiskLabel("Crypto Wallet")local path=fs.combine(drive.getMountPath(),"wallet.db")if fs.exists(path)and not fs.isDir(path)then local file=fs.open(path,"r")local priv=file.read(32)if priv then if#priv~=32 then error(("The wallet file may be corrupted.\nExpected length: 32, got: %d"):format(#priv))end else error("Wallet file was empty. The file may be corrupted.")end file.close()return priv end local priv=blake3(rand.random(64),32)local file=fs.open(path,"w")file.write(priv)file.close()return priv end local BASE58_ALPHABET="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" local function pubkeyToAddress(pubkey)local checksum=blake3(blake3(pubkey),4)local payload=pubkey..checksum local leadingZeros=0 for i=1,#payload do if payload:byte(i)~=0 then break end leadingZeros=leadingZeros+1 end local num={}for i=1,#payload do local byte=payload:byte(i)for j=#num,1,-1 do byte=byte+num[j]*256 num[j]=byte%58 byte=math.floor(byte/58)end while byte>0 do table.insert(num,1,byte%58)byte=math.floor(byte/58)end end local result=string.rep('1',leadingZeros)for _,d in ipairs(num)do result=result..BASE58_ALPHABET:sub(d+1,d+1)end return result end local function _buildBase58Map()local map={}for i=1,#BASE58_ALPHABET do local char=BASE58_ALPHABET:sub(i,i)map[char]=i-1 end return map end local function _base58Decode(input)local base58Map=_buildBase58Map()local num={0}for i=1,#input do local c=input:sub(i,i)local digit=base58Map[c]if not digit then return nil end local carry=digit for j=#num,1,-1 do local n=num[j]*58+carry num[j]=n%256 carry=math.floor(n/256)end while carry>0 do table.insert(num,1,carry%256)carry=math.floor(carry/256)end end local leadingZeros=0 for i=1,#input do if input:sub(i,i)~='1' then break end leadingZeros=leadingZeros+1 end for i=1,leadingZeros do table.insert(num,1,0)end return string.char(table.unpack(num))end local function isBase58Address(address)local payload,err=_base58Decode(address)if not payload then return false end if#payload~=36 then return false end local pubkey=payload:sub(1,32)local checksum=payload:sub(33,36)local computedChecksum=blake3(blake3(pubkey),4)return checksum==computedChecksum end return{getPrivate=getPrivate,pubkeyToAddress=pubkeyToAddress,isBase58Address=isBase58Address}end __modules["popularity"]=function()local toleranceMul=160 local function computeMostPopular(ledgerObjects)local olen=#ledgerObjects if olen==0 then return nil elseif olen==1 then return ledgerObjects[1].ledger elseif olen==2 then return ledgerObjects[math.random(2)].ledger end local sum=0 for _,l in ipairs(ledgerObjects)do sum=sum+l.dist end local epsilon=toleranceMul*math.log(sum/olen,10)table.sort(ledgerObjects,function(a,b)return a.dist<b.dist end)local filteredChain={}local lastDist=-math.huge for _,l in ipairs(ledgerObjects)do if lastDist+epsilon<l.dist then table.insert(filteredChain,l)end lastDist=l.dist end local filtered={}lastDist=-math.huge for _,l in ipairs(filteredChain)do if math.abs(l.dist-lastDist)>epsilon then table.insert(filtered,l)lastDist=l.dist end end local popularities={}for _,l in ipairs(filtered)do local hash=l.ledger:hash()popularities[hash]=(popularities[hash]or 0)+1 end local highestCount=-math.huge local mostPopularHash=nil for hash,count in pairs(popularities)do if count>highestCount then highestCount=count mostPopularHash=hash end end for _,l in ipairs(filtered)do if l.ledger:hash()==mostPopularHash then return l.ledger end end return nil end return computeMostPopular end local autoupdate=true local NETWORK_CHANNEL=8912 local MINTED_AMOUNT=15000000000 local ed25519=require "ccryptolib.ed25519" local blake3=require "ccryptolib.blake3".digest local walletLib=require "wallets" local computeMostPopular=require "popularity" local _modems={peripheral.find("modem",function(_,modem)return modem.isWireless()end)}local modem=_modems[1]or error("No wireless modem found!\nPlease attach a wireless ender modem to the computer.")local function clear()term.clear()term.setCursorPos(1,1)end local function extends(a,b)for i=1,#b do local elementA=a[i]local elementB=b[i]if not elementA then return false end if type(elementB)=="table" then if type(elementA)~="table" or not extends(elementA,elementB)then return false end elseif elementA~=elementB then return false end end return true end local function printC(color,...)local before=term.getTextColor()term.setTextColor(color)print(...)term.setTextColor(before)end local function pbinPut(data)local width,_=term.getSize()local file=fs.open("___wallet_address","w")file.write(data)file.close()printC(colors.red,"\n"..("\x7f"):rep(width))shell.run("pastebin put ___wallet_address")printC(colors.red,("\x7f"):rep(width).."\n")fs.delete("___wallet_address")end local function checkTransactionFields(request)if type(request)~="table" then return false end return type(request.from)=="string" and type(request.to)=="string" and type(request.amount)=="number" and type(request.timestamp)=="number" and type(request.signature)=="string" end Transaction={}Transaction.__index=Transaction function Transaction:new(from,to,amount,timestamp,signature)local self=setmetatable({},Transaction)self.from=from self.to=to self.amount=amount self.timestamp=timestamp self.signature=signature return self end function Transaction:isValid()if not checkTransactionFields(self)then return false end if self.from=="genesis" then return self.amount==MINTED_AMOUNT and self.timestamp==0 and self.signature=="" end if not walletLib.isBase58Address(self.to)then return false end if walletLib.pubkeyToAddress(self.from)==self.to then return false end local message=textutils.serialize({self.from,self.to,self.amount,self.timestamp},{compact=true})if not ed25519.verify(self.from,message,self.signature)then return false end if self.amount<=0 then return false end if self.amount~=math.floor(self.amount)then return false end if self.timestamp<=0 then return false end return true end Ledger={}Ledger.__index=Ledger function Ledger:new()local self=setmetatable({},Ledger)self.transactions={}return self end function Ledger:isValid()for i,tx in ipairs(self.transactions)do local previous=self.transactions[i-1]if previous then if tx.timestamp<previous.timestamp then return false end elseif ( tx.from~="genesis" or tx.amount~=MINTED_AMOUNT or tx.timestamp~=0 or tx.signature~="")then return false end if not tx:isValid()then return false end end local balances={}for _,tx in ipairs(self.transactions)do local sender if tx.from~="genesis" then sender=walletLib.pubkeyToAddress(tx.from)else sender="genesis" end balances[sender]=(balances[sender]or 0)-tx.amount balances[tx.to]=(balances[tx.to]or 0)+tx.amount end for addr,bal in pairs(balances)do if addr=="genesis" and bal~=-MINTED_AMOUNT then return false end if bal<0 and addr~="genesis" then return false end end return true end function Ledger:balanceOf(address)local balance=0 for _,tx in ipairs(self.transactions)do if tx.to==address then balance=balance+tx.amount end local senderAddress=walletLib.pubkeyToAddress(tx.from)if senderAddress==address then balance=balance-tx.amount end end return balance end function Ledger:hash()return blake3( textutils.serialize(self.transactions,{compact=true}))end local function syncLedgerByNetwork(comparison)local ledgers={}printC(colors.blue,"Gathering ledgers...")parallel.waitForAny( function()sleep(10)if#ledgers<1 and#comparison.transactions==0 then printC(colors.red,"Timeout passed, but no ledgers were received. Are you sure the modem you're using is an ender modem, or that there are any other nodes on the network?")parallel.waitForAny( function()repeat sleep(1)until#ledgers>0 end,function()printC(colors.red,"\nClick to stop...")os.pullEvent("mouse_click")error("No ledgers found")end)end end,function()term.setTextColor(colors.green)while true do local _,_,_,_,msg,dist=os.pullEvent("modem_message")if msg and dist then printC(colors.green,"New ledger received!")if extends(msg,comparison)then setmetatable(msg,Ledger)for _,tx in ipairs(msg.transactions)do setmetatable(tx,Transaction)end table.insert(ledgers,{ledger=msg,dist=dist})end end end end)term.setTextColor(colors.white)if#ledgers<1 then return nil end local realLedger=computeMostPopular(ledgers)if not realLedger then error("No valid ledger was found!")end return realLedger end local function ledgerInit()local save=fs.open("ledger.db","r")local cachedLedger=Ledger:new()if save then local contents=save.readAll()if contents~="" then cachedLedger=textutils.unserialize(contents)for _,tx in ipairs(cachedLedger.transactions)do setmetatable(tx,Transaction)end end save.close()end local networkLedger=syncLedgerByNetwork(cachedLedger)if not networkLedger then return cachedLedger end local realLedger if networkLedger:isValid()then realLedger=networkLedger elseif cachedLedger:isValid()then realLedger=cachedLedger else error("Cached ledger was invalid.")end return realLedger end local function handleTransactionRequest(baseLedger,request)if not checkTransactionFields(request)then return baseLedger end if type(request.timestamp)=="number" then if not ( request.timestamp-2000<os.epoch()and request.timestamp+2000>os.epoch())then return baseLedger end else return baseLedger end local transaction=Transaction:new( request.from,request.to,request.amount,request.timestamp,request.signature)local newLedger=Ledger:new()for i=1,#baseLedger.transactions do table.insert(newLedger.transactions,baseLedger.transactions[i])end table.insert(newLedger.transactions,transaction)if not newLedger:isValid()then return baseLedger end return newLedger end local function sendTransactionRequest(ledger,privateKey,receiverAddress,amount)local pub=ed25519.publicKey(privateKey)local request={}request.from=pub request.to=receiverAddress request.amount=amount request.timestamp=os.epoch()request.signature=ed25519.sign( privateKey,pub,textutils.serialize({request.from,request.to,request.amount,request.timestamp},{compact=true}))modem.transmit(NETWORK_CHANNEL,NETWORK_CHANNEL,request)return handleTransactionRequest(ledger,request)end local function startNode(genesisLedger)local _ope=os.pullEvent os.pullEvent=os.pullEventRaw modem.closeAll()modem.open(NETWORK_CHANNEL)local ledger=genesisLedger or ledgerInit()parallel.waitForAny( function()while true do local _,_,_,_,msg=os.pullEvent("modem_message")if msg then ledger=handleTransactionRequest(ledger,msg)end end end,function()while true do sleep(10)modem.transmit( NETWORK_CHANNEL,NETWORK_CHANNEL,ledger)end end,function()while true do do clear()printC(colors.green,"\xbb NODE RUNNING")printC(colors.blue,"Actions:")printC(colors.blue,"\n'transfer':")printC(colors.white,"Transfer money to an address. Irreversible!")printC(colors.blue,"\n'wallet':")printC(colors.white,"Check the status of your wallet.")printC(colors.blue,"\n'ledger':")printC(colors.white,"Display the agreed upon ledger.")printC(colors.blue,"\n'stop':")printC(colors.white,"Stop the node.")write("\n> ")end local input=read():match("^%s*(.-)%s*$")clear()if input=="transfer" then clear()printC(colors.green,"Transfer funds\n")term.setTextColor(colors.blue)write("Receiver address: ")term.setTextColor(colors.white)local address=read():match("^%s*(.-)%s*$")term.setTextColor(colors.blue)write("Amount: ")term.setTextColor(colors.white)local amount=tonumber(read():match("^%s*(.-)%s*$"))if not amount then printC(colors.red,"Please enter a valid number!")else local previous=ledger:hash()ledger=sendTransactionRequest( ledger,walletLib.getPrivate(),address,amount)printC(colors.cyan,"\nRequest sent to network...\n")local new=ledger:hash()if previous~=new then printC(colors.green,"Transaction appears to have been successful!")else printC(colors.red,"The ledger is unchanged. This likely means your transaction failed.")end end print("\nClick to continue...")os.pullEvent("mouse_click")elseif input=="wallet" then local address=walletLib.pubkeyToAddress( ed25519.publicKey(walletLib.getPrivate()))printC(colors.blue,"Public address:")print(address)printC(colors.blue,"\nBalance:")print(ledger:balanceOf(address))printC(colors.blue,"\nPut address on pastebin?")write("[y/n]> ")if read()=="y" then pbinPut(address)print("Click to continue...")os.pullEvent("mouse_click")end elseif input=="ledger" then clear()__dynamic_require "cc.pretty".pretty_print(ledger)printC(colors.red,"Click to continue...")os.pullEvent("mouse_click")elseif input=="stop" then term.setTextColor(colors.red)print("WARNING: Are you sure you want to stop the node?")print("This will temporarily desync it from the network, and should generally only be done if the node needs updating or maintance.")term.setTextColor(colors.white)write("[y/n]> ")if read()=="y" then return end else print("Unknown command!")sleep(1)end end end)os.pullEvent=_ope if ledger:isValid()then local save=fs.open("ledger.db","w")save.write(textutils.serialize(ledger,{compact=true}))save.close()end end clear()local args={...}local genesisLedger if args[1]=="genesis" then clear()printC(colors.green,"Creating genesis node...")genesisLedger=setmetatable({},Ledger)genesisLedger.transactions={}local ownerAddress=walletLib.pubkeyToAddress( ed25519.publicKey(walletLib.getPrivate()))local genesisTx=Transaction:new( "genesis",ownerAddress,MINTED_AMOUNT,0,"")table.insert(genesisLedger.transactions,genesisTx)if genesisLedger:isValid()then local save=fs.open("ledger.db","w")save.write(textutils.serialize(genesisLedger,{compact=true}))save.close()end elseif args[1]=="wallet" then clear()printC(colors.blue,"Your wallet address is:")local address=walletLib.pubkeyToAddress( ed25519.publicKey(walletLib.getPrivate()))print(address.."\n")printC(colors.blue,"Placing on pastebin...")pbinPut(address)end local pname=shell.getRunningProgram()if pname~="startup.lua" then if fs.exists("startup.lua")then printC(colors.red,"Moving existing `startup.lua` to `_old_startup.lua`")fs.move("startup.lua","_old_startup.lua")end fs.move(pname,"startup.lua")end parallel.waitForAny( function()startNode(genesisLedger)end,function()while true do if autoupdate then local f=fs.open("startup.lua","r")local currentHash=blake3(f.readAll())f.close()local newContentsRequest=http.get("https://raw.githubusercontent.com/mrMalinka/cc-cryptocoin/refs/heads/main/startup.lua")if newContentsRequest then local newContents=newContentsRequest.readAll()local newHash=blake3(newContents)if currentHash~=newHash then local newFile=fs.open("startup.lua","w")newFile.write(newContents)newFile.close()os.reboot()end end end sleep(60*15)end end)